#!/usr/bin/env perl
use File::Basename 'dirname';
use File::Spec;
BEGIN {
  my @libdir = File::Spec->splitdir(dirname(__FILE__));
  use lib join '/', @libdir, 'lib';
  use lib join '/', @libdir, '..', 'lib';
};
use Mojolicious::Lite;
use Mojo::ByteStream 'b';
use DBI;
use DBD::SQLite;
use XML::Loy::Atom;
use XML::Loy::Date::RFC3339;
use XML::Loy::Date::RFC822;

my $DC_NS = 'http://purl.org/dc/elements/1.1/';

app->mode('development');

# Several namespaces for RSS
my $RSS_NS_RE =
  qr{^http://
     (?:www\.rssboard\.org/rss-specification|
       my\.netscape\.com/rdf/simple/0\.9/|
       backend\.userland\.com/rss2|
       purl\.org/(?:rss/1\.0/(?:modules/rss091)?|net/rss1\.1)
     )\#?$}x;

# Maybe initialize the database
my $file = app->home . '/pubsub.sqlite';
sub _init_file;
unless (-e $file) {
  die 'Unable to init database' unless _init_db($file);
};


# Create database handler helper
helper dbh => sub {
  state $dbi = DBI->connect("dbi:SQLite:dbname=" . $file, "", "");
};

helper own_entries => sub {
  my $c = shift;
  return $c->dbh->selectall_arrayref(<<'ENTRIES', { Slice => {} });
SELECT *
FROM PubSub_content
WHERE internal = 1
ORDER BY updated DESC
LIMIT 20 OFFSET 0
ENTRIES
};


# Register pubSubHubbub plugin
plugin 'PubSubHubbub';


# Add 'acceptance' callback
app->callback(pubsub_accept => sub {
  my ($c, $type, $topics) = @_;

  # create quoted topic string
  my $topic_string = join(',', map(b($_)->quote, grep { $_ } @$topics));

  # Get topics and associated secrets
  my $db_request = <<"SELECT_TOPICS";
SELECT
  topic, secret FROM PubSub
WHERE
  topic in ($topic_string)
  AND mode = "subscribe"
  AND pending = 0
  AND (
    lease_seconds is NULL
    OR (started + lease_seconds) <= date("now")
  )
SELECT_TOPICS

  my $dbh = $c->dbh;
  my $array = $dbh->selectall_arrayref($db_request);

  # Todo: Is the hub the one I subscribed to?

  my (%topics, $secret);

  # Iterate through all topics
  foreach (@$array) {

    # No secret needed
    unless ($_->[1]) {

      # Topic is valid
      $topics{$_->[0]} = 1;
    }

    # Secret needed
    else {

      # No secret given
      if (!$secret) {

	# Init secret
	$secret = $_->[1] if $_->[1];
      }

      # Secret already given and mismatched for bulk
      elsif ($secret ne $_->[1]) {
	$c->app->log->info(
	  "Hub for topics $topic_string expects " .
	  'different secrets for bulk.');
	next;
      };

      # Secret matches for bulk
      $topics{$_->[0]} = 1;
    };
  };

  # Return filtered topics and secret
  return ([keys %topics], $secret);
});


# Add verification callback
app->callback(pubsub_verify => sub {
  my ($c, $params) = @_;

  my $dbh = $c->dbh;

  # Get subsrciption
  my $subscr = $dbh->selectrow_hashref(
    'SELECT FROM PubSub WHERE topic = ? AND mode = ? AND verify_token = ?',
    {Slice => {} },
    @{$params}{qw/topic mode verify_token/}
  );

  # No subscription of this topic found
  return unless $subscr;

  $dbh->begin_work;

  # Is subscription time over?
  if ($subscr->{lease_seconds} &&
	(time > ($subscr->{started} + $subscr->{lease_seconds}))) {

    # Delete Subscription (Maybe too hard?)
    unless ($dbh->do('DELETE FROM PubSub WHERE id = ?', $subscr->{id})) {
      $dbh->rollback and return;
    };
  };

  # If mode is subscribe and pending, update pending status

  # Maybe
  if ($subscr->{pending} && $subscr->{mode} eq 'subscribe') {
    unless ($dbh->do(
      'UPDATE PubSub SET pending = 0 WHERE id = ?', $subscr->{id}
    )) {
      $dbh->rollback and return;
    }
  }

  # If mode is unsubscribe, delete subscription
  # Maybe this is wrong?
  elsif ($subscr->{mode} eq 'unsubscribe') {

    # Delete subscription
    unless ($dbh->do('DELETE FROM PubSub WHERE id = ?', $subscr->{id})) {
      $dbh->rollback and return;
    };
  };

  # Everything is fine
  $dbh->commit;

  # Verify subscription
  return 1;
});


# How to handle the newly arrived content?
# Todo: Make this a unifying plugin
hook on_pubsub_content => sub {
  my ($c, $type, $dom) = @_;

  my (@feed, $author);

  my $elem = $dom->at('creator');
  if ($elem && $elem->namespace eq $DC_NS) {
    $author = $elem->all_text;
  };

  # Feed is Atom
  if ($type eq 'atom') {

    $elem = $dom->at('author > name');
    my $author = $elem ? $elem->all_text : $author;

    $dom->find('entry')->each(
      sub {
	my $entry = shift;

	my %info = (
	  topic => $entry->at('source > link[rel="self"]["href"]')->attrs('href')
	);

	foreach (qw/title id updated content/) {
	  $elem = $entry->at($_);
	  $_ = 'guid' if $_ eq 'id';
	  $info{$_} = $elem ? $elem->all_text : '';
	};

	# $elem = $entry->at('author entry'); ???
	$elem = $entry->at('author');
	$info{author} = $elem->all_text || $author;

	if ($info{updated}) {
	  $info{updated} = XML::Loy::Date::RFC3339->new( $info{updated} )->epoch;
	}
	elsif ($elem = $entry->at('date') && $elem->namespace eq $DC_NS) {
	  $info{updated} = XML::Loy::Date::RFC3339->new($elem->text)->epoch
	};

	$info{updated} ||= time;

	push(@feed, \%info);
      }
    );
  }

  # Feed is RSS
  elsif ($type eq 'rss') {

    $dom->find('item')->each(
      sub {
	my $entry = shift;

	my %info = (
	  topic => $entry->at('source > link[rel="self"]["href"]')->attrs('href')
	);

	foreach (qw/title guid pubDate description/) {
	  $elem = $entry->at($_);

	  # Rename pubDate
	  if ($_ eq 'pubDate') {
	    $_ = 'updated';
	  }

	  # Rename description
	  elsif ($_ eq 'description') {
	    $_ = 'content';
	  };

	  $info{$_} = $elem ? $elem->all_text : '';
	};

	$elem = $entry->at('author');
	$info{author} = $elem->all_text || $author;

	# Check rdf:about
	$info{guid} //= $entry->attrs('rdf:about');

	my $link = $entry->at('link');
	if ($link && (!$link->namespace || $link->namespace =~ $RSS_NS_RE)) {
	  $info{link} = $link->text;
	};

	# Set updated to epoch time
	if ($info{updated}) {
	  $info{updated} = XML::Loy::Date::RFC822->new( $info{updated} )->epoch;
	}

	elsif ($elem = $entry->at('date') && $elem->namespace eq $DC_NS) {
	  $info{updated} = XML::Loy::Date::RFC3339->new($elem->text)->epoch
	};

	push(@feed, \%info);
      });
  };

  my $dbh = $c->dbh;
  my $sth = $dbh->prepare(
    'INSERT INTO PubSub_content ' .
      '(topic, author, updated, title, content, link, internal) ' .
	'VALUES ' .
	  '(?,?,?,?,?,?,0)'
  );

  # Start transaction
  $dbh->begin_work;

  # Todo: Do update_or_insert(PubSub_content => {} => {
  #            guid => $guid, topic => $topic })
  # If guid is given

  # Import all entries to database
  foreach my $entry (@feed) {
    $sth->execute(@{$entry}{qw/topic author updated title content/});
  };

  # Commit insertions
  $dbh->commit;
};


# before_pubsub_(un)?subscribe
sub _store_subscription {
  my ($c, $param, $post) = @_;

  my %cond;

  my @first  = qw(hub lease_seconds secret verify_token mode pending started);
  my @second = qw(topic mode);

  $param->{pending} = 1;
  $param->{started} = time;

  my @values = (@{$param}{@first}, @{$param}{@second});

  my $sql =
    'UPDATE PubSub SET ' .
      join(', ', map { $_ . ' = ?' } @first) .
	' WHERE ' .
	  join(' AND ', map { $_ . ' = ?' } @second);

  my $dbh = $c->dbh;

  $c->app->log->error('Update subscription ' . $sql);

  my $sth = $dbh->prepare($sql);

  unless ($sth) {
    $c->app->log->error('Unable to prepare ' . $sql);
    return;
  };

  unless ($sth->execute(@values) >= 1) {

    $sql = 'INSERT INTO PubSub (' .
	join(',', @first, @second) . ') VALUES (' . join(',', ('?') x 9) . ')';

    $c->app->log->error('Insert subscription ' . $sql);

    $sth = $dbh->prepare($sql);

    unless ($sth->execute(@values)) {
      $c->app->log->error('Unable to ' . $param->{mode} . ' to ' . $param->{topic});
    };
  };
  return;
};


# Unified event for subscription and unsubscribing
hook before_pubsub_subscribe => \&_store_subscription;


hook after_pubsub_subscribe => sub {
  my $c = shift;
  $c->app->log->error('Successful subscribed');
};

# Unified event for subscription and unsubscribing
hook before_pubsub_unsubscribe => \&_store_subscription;


##############
# Set routes #
##############
(any '/ps-callback')->pubsub;

# Show last content and subscription form
get '/' => sub {
  my $c = shift;

  my $dbh = $c->dbh;

  my $subscriptions = $dbh->selectall_arrayref(<<'SUBS', { Slice => {} });
SELECT * FROM PubSub
SUBS

  my $entries = $dbh->selectall_arrayref(<<'ENTRIES', { Slice => {} });
SELECT PubSub_content.*, PubSub.id as topic_id
FROM PubSub_content, PubSub
WHERE internal = 0 AND PubSub_content.topic = PubSub.topic
ORDER BY updated DESC
LIMIT 20 OFFSET 0
ENTRIES

  my $own_entries = $c->own_entries;

  # Todo: Get latest entries
  $c->render(
    template => 'index',
    entries  => $entries,
    own_entries => $own_entries,
    subscriptions => $subscriptions
  );
} => 'index';

get '/entry/:id' => [id => qr/\d+/] => sub {
  my $c   = shift;
  my $id  = $c->stash('id');
  my $dbh = $c->dbh;

  my $entry = $dbh->selectrow_hashref(
    'SELECT * FROM PubSub_content WHERE internal = 1 AND id = ?',
    { Slice => {} },
    $id
  );

  return $c->render_not_found unless $entry;

  $c->render(
    template => 'entry',
    entry => $entry
  );
};

get '/topic/:id' => [id => qr/\d+/] => sub {
  my $c   = shift;
  my $id  = $c->stash('id');
  my $dbh = $c->dbh;

  my $entries = $dbh->selectall_arrayref(
'SELECT * FROM PubSub_content.*, PubSub.id AS topic_id
WHERE PubSub.topic = PubSub_content.topic AND PubSub.id = ?
ORDER BY updated DESC LIMIT 10', { Slice => {} }, $id);

  # Show topic
  if ($entries && @$entries >= 1) {
    return $c->render(
      template => 'topic',
      topic_id => $id,
      entries  => $entries,
      topic    => $entries->[0]->{topic}
    );
  };

  # Topic unknown
  return $c->render_not_found;
} => 'topic';

get '/unsubscribe/:id' => [id => qr/\d+/] => sub {
  my $c = shift;
  my $id   = $c->stash('id');
  my $dbh  = $c->dbh;

  my $feed = $dbh->selectrow_arrayref(
    'SELECT topic, mode, hub, secret, verify_token ' .
      'FROM PubSub WHERE id = ?',
    { Slice => {} },
    $id
  );

  if ($feed) {
    if ($feed->{topic} && $feed->{mode} eq 'subscribe') {

      delete $feed->{mode};

      if ($c->pubsub_unsubscribe( %$feed )) {
	$c->flash(message => 'You unsubscribed from ' . $feed->{topic});
      }

      else {
	$c->flash(message => 'Unable to unsubscribe from ' . $feed->{topic});
      };
    }

    else {
      $c->flash(message => 'You are not subscribe to that feed.');
    };
  }

  else {
    $c->flash(message => 'You did not subscribe to that feed.');
  };

  return $c->redirect_to('index');
} => 'unsubscribe';


# Subscribe to new feed
sub _subscribe {
  my $c = shift;

  my $hub    = $c->param('hub');
  my $topic   = $c->param('topic');
  my $secret = $c->param('secret');

  # Missing information
  unless ($hub && $topic) {

    # Set information to flash
    $c->flash(
      hub    => $hub,
      feed   => $topic,
      secret => $secret
    );

    # Retry
    return $c->redirect_to('index');
  };

  # Create new parameter hash
  my %new_param = (
    topic => $topic,
    hub   => $hub
  );

  # Set secret
  $new_param{secret} = $secret if $secret;

  # Subscribe to new feed
  if ($c->pubsub_subscribe( %new_param )) {
    $c->flash(message => 'You subscribed to ' . $topic);
  }

  # Failed to subscribe to new feed
  else {
    $c->flash(message => 'Unable to subscribe to ' . $topic . ':' . $hub);
  };

  # Todo: Update stored database

  # Redirect
  return $c->redirect_to('index');
};

post '/' => \&_subscribe;
get '/subscribe' => \&_subscribe;


get '/discover' => sub {
  my $c = shift;
  my $uri = $c->param('uri');
  return $c->render_not_found unless $uri;

  my ($topic, $hub) = $c->pubsub_discover($uri);

  $c->flash(hub => $hub) if $hub;
  $c->flash(topic => $topic) if $topic;
  $c->flash(uri => $uri);

  return $c->redirect_to('index');
} => 'discover';

# Get feed
get '/feed' => sub {
  my $c = shift;
  my $atom = XML::Loy::Atom->new('feed');
  $atom->link(self => $c->url_for('feed')->to_abs);
  $atom->link(hub => $c->endpoint('pubsub-hub'));

  my $own_entries = $c->own_entries;

  foreach my $own (@$own_entries) {
    my $entry = $atom->entry(
      id => $own->{guid}
    );
    for ($entry) {
      $_->author(name => $own->{author});
      $_->title($own->{title});
      $_->updated($own->{updated});
      $_->content($own->{content});
      $_->link(
	rel => 'alternate',
	href => $own->{link},
	type => 'text/html'
      )
    };
  };

  $c->render(data => $atom->to_pretty_xml);
  $c->res->headers->content_type($atom->mime);

  return;
} => 'feed';


# Post new entry
post '/entry' => sub {
  my $c = shift;

  my $dbh = $c->dbh;

  my $author  = $c->param('author');
  my $title   = $c->param('title');
  my $content = $c->param('content');

  if ($author && $title && $content) {

    $dbh->begin_work;

    my $sth = $dbh->prepare(<<'CONTENT');
INSERT INTO PubSub_content (author, title, content, topic, updated, internal)
VALUES (?, ?, ?, ?, ?, 1)
CONTENT

    my $topic = $c->url_for('feed')->to_abs;

    if ($sth && $sth->execute($author, $title, $content, $topic, time)) {
      my $id = $dbh->last_insert_id(undef, undef, undef, undef);
      my $guid = $c->url_for->to_abs . '/' . $id;
      $sth = $dbh->prepare(<<'GUID');
UPDATE PubSub_content SET guid = ?, link = ? WHERE id = ?
GUID

      if ($guid && $sth && $sth->execute($guid, $guid, $id)) {
	$dbh->commit;

	$c->flash(message => 'You posted a new entry');
	$title = undef;
	$content = undef;
      }

      else {
	$c->flash(message => 'Failed to post new entry - please retry');
	$dbh->rollback;
      };
    }
    else {
      $c->flash(message => 'Failed to post new entry - please retry');
      $dbh->rollback;
    };
  }

  else {
    $c->flash(message => 'Please define author, title and content');
  };

  $c->flash(author => $author)   if $author;
  $c->flash(title => $title)     if $title;
  $c->flash(content => $content) if $content;
  return $c->redirect_to('index');
} => 'entry';



get '/css/styles' => sub {
  shift->render(
    template => 'styles',
    format => 'css'
)} => 'styles';


#######################
# Initialize Database #
#######################
sub _init_db {
  my $file = shift;

  my $dbh = DBI->connect("dbi:SQLite:dbname=$file", '', '');

  $dbh->begin_work;

  # Topic subscription
  unless ($dbh->do(
    'CREATE TABLE PubSub (
       id            INTEGER PRIMARY KEY,
       topic         TEXT NOT NULL,
       mode          TEXT NOT NULL,
       hub           TEXT,
       pending       INTEGER,
       lease_seconds INTEGER,
       secret        TEXT,
       verify_token  TEXT,
       started       INTEGER
     )'
  )) {
    $dbh->rollback and return;
  };

  # Topic subscription indices
  unless ($dbh->do(
    'CREATE INDEX IF NOT EXISTS pubsub_topic_i on PubSub (topic)'
  )) {
    $dbh->rollback and return;
  };

  # Content
  unless ($dbh->do(
    'CREATE TABLE PubSub_content (
       id       INTEGER PRIMARY KEY,
       author   TEXT,
       guid     TEXT,
       title    TEXT,
       updated  INTEGER,
       content  TEXT,
       link     TEXT,
       topic    TEXT,
       internal BOOLEAN
     )')) {
    $dbh->rollback and return;
  };

  # Content indices
  foreach (qw/guid updated/) {
    unless ($dbh->do(
      "CREATE INDEX IF NOT EXISTS pubsub_content_${_}_i on PubSub_content (${_})"
    )) {
      $dbh->rollback and return;
    }
  };

  # Everything went fine
  $dbh->commit and return 1;
};


app->helper(
  text_shorten => sub {
    my $c      = shift;
    my $text   = shift or return '';
    my $length = shift || 200;
    return substr($text, 0, $length);
  });


app->start;

__DATA__

@@ layouts/index.html.ep
<!doctype html>
<html>
  <head>
    <title><%= $title %></title>
%= stylesheet url_for 'styles'
  </head>
  <body>
    <h1><%= $title %></h1>
%== content
  </body>
</html>

@@ article.html.ep
<article>
  <h2><a href="<%= $entry->{link} || '#' %>"><%= $entry->{title} %></a></h2>

% my $date = $entry->{updated} ?
%    XML::Loy::Date::RFC3339->new($entry->{updated})->to_string : '';

  <p class="byline">von <%= $entry->{author} %>, <%= $date %></p>
  <p><%= text_shorten($entry->{content}, 200) %></p>
% if ($entry->{topic_id}) {
  <p>Topic: <a href="<%= url_for 'topic', id =>  $entry->{topic_id} %>"><%= $entry->{topic} || 'Unknown' %></a></p>
% };
</article>


@@ index.html.ep
% layout 'index', title => 'PubSubHubbub';

% my $subs = stash('subscriptions') || [];
% my $content = stash('entries') || [];

% if (my $m = flash('message')) {
%   if ($m =~ /unable/i) {
<p style="color: red"><%= $m %></p>
%   } else {
<p style="color: green"><%= $m %></p>
%   };
% };

<div id="left"><h2>New Subscription</h2>

<p>Hub: <a href="<%= endpoint 'pubsub-hub' %>"><%= endpoint 'pubsub-hub' %></a>, CB: <a href="<%= endpoint 'pubsub-callback' %>"><%= endpoint 'pubsub-callback' %></a></p>

<form method="get" action="<%= url_for 'discover' %>">
  <input type="text" name="uri" id="uri" value="<%= flash('uri') %>" />
  <input type="submit" value="Discover" />
</form>

<br />

<form method="post" action="<%= url_for 'index' %>">
% foreach (qw/topic hub secret/) {
  <label for="<%= $_ %>"><%= ucfirst($_) %></label>
  <input type="text" name="<%= $_ %>" id="<%= $_ %>" value="<%= flash($_) %>" />
  <br />
% }
  <input type="submit" value="OK" />
</form>

% if (@$subs) {
<h2>Subscriptions</h2>
<ul id="subscriptions">
% foreach my $sub ( @$subs ) {
  <% if ($sub->{mode} eq 'unsubscribe') { %>
  <li class="unsubscribed">
  <% } elsif ($sub->{pending}) { %>
  <li class="pending">
  <% } else { %>
  <li>
  <% } %>
    <a href="<%= url_for 'topic', id => $sub->{id} %>"><%= $sub->{topic} %></a>
    <% if ($sub->{pending} || $sub->{mode} eq 'unsubscribe') { %>
%     my %new_param =  (topic => $sub->{topic},
%                       hub   => $sub->{hub});
%     $new_param{secret} = $sub->{secret} if $sub->{secret};
%     my $url = url_for '/subscribe';
%     $url->query( %new_param );
    <a href="<%= $url %>">resubscribe</a>
    <% } else { %>
    <a href="<%= url_for 'unsubscribe', id => $sub->{id} %>">unsubscribe</a>
    <% } %>
  </li>
% };
</ul>
% };

% if (@$entries) {
<h2>Content</h2>
%   foreach my $entry ( @$entries ) {
%= include 'article', entry => $entry
%   };
% };

</div>
<div id="right"><h2>New post</h2>

<form method="post" action="<%= url_for 'entry' %>">
% foreach (qw/author title/) {
  <label for="<%= $_ %>"><%= ucfirst $_ %></label>
  <input type="text" name="<%= $_ %>" value="<%= flash $_ %>" /><br />
% }
  <textarea name="content"><%= flash 'content' %></textarea>
  <input type="submit" value="Post" />
</form>

% foreach my $entry ( @$own_entries ) {
%= include 'article', entry => $entry
% };

</div>

@@ topic.html.ep
% my $content = stash('entries') || [];
% layout 'index', title => 'Show ' . $topic;

% foreach my $entry ( @$content ) {
%= include 'article', entry => $entry
% };

@@ entry.html.ep
% layout 'index', title => 'Show ' . $entry->{guid};
%= include 'article', entry => $entry


@@ styles.css.ep
html {
  height: 100%;
  font-family: tahoma, verdana, arial;
}

ul#subscriptions {
  font-size: 80%;
  margin: 2px;
  border: 2px solid black;
  background-color: #ffddff;
}

ul#subscriptions li.pending {
  background-color: #ddffdd;
}

ul#subscriptions li.unsubscribed {
  background-color: #ff0000;
}

form {
  padding: .5em;
}

div#left form {
  background-color: grey;
}

input, textarea {
  border: 1px solid black;
}

textarea {
  width: 24em;
  height: 20em;
}

div#left, div#right {
  display: block;
  width: 50%;
}

div#left {
  float: right;
}

label {
  display: inline-block;
  width: 5em;
}

article {
  position: relative;
  background-color: white;

  margin: 12px auto 0px auto;

  max-width: 800px;
  min-width: 300px;

  padding: 0px 10px;

  font-size: 11px;
  line-height: 1.7em;
  color: #333;

  border: 2px solid #444;
  border-radius: 10px;

  box-shadow: 4px 4px 3px rgba(0, 0, 0, .6);

  text-align: justify;
  -moz-hyphen: auto;
  -webkit-hyphen: auto;
  hyphen: auto;
}

article h2 {
  font-size: 15px;
  margin-top: .3em;
  margin-bottom: 0;
  padding-bottom: 0;
  border-bottom: 1px solid #777;
}

article h2 a {
  color: #000;
  text-decoration: none;
}

article p {
  margin: 0 20px 1.1em 10px;
}

p.byline {
  margin: 0 0 5px 0;
  font-size: 80%;
  color: #777;
}

p:last-child {
   margin-bottom: .4em;
}
